--- ./plugins/Makefile.in.orig	2010-06-03 20:06:35.000000000 +0200
+++ ./plugins/Makefile.in	2010-06-03 20:06:49.000000000 +0200
@@ -3,5 +3,7 @@ include %%topdir%%/config.mk
 SUBDIRS = taskbar launchbar space menu pager mem chart cpu net
 SUBDIRS += systray dclock wincmd icons separator image
 SUBDIRS += deskno tclock genmon deskno2
+# CLIP
+SUBDIRS += rmlaunch mltaskbar batt label minmax
 
 include %%topdir%%/rules.mk
--- ./plugins/menu/menu.c.orig	2010-06-03 20:06:35.000000000 +0200
+++ ./plugins/menu/menu.c	2010-06-03 20:06:49.000000000 +0200
@@ -28,13 +28,29 @@ gboolean systemmenu_changed();
 static void menu_create(plugin_instance *p); 
 static void menu_destroy(menu_priv *m);
 
+/* CLIP */
+xconf * menu_expand_xc(xconf *xc, panel *p);
+
+xconf *
+menu_expand_include(char *name, panel *p)
+{
+    xconf *xc, *exc;
+
+    xc = xconf_new_from_file(name, "menu", p);
+    exc = menu_expand_xc(xc, p);
+
+    return exc;
+}
+
+/* /CLIP */
+
 /* Copies original config while replacing specific entries
  * with autogenerated configs */
 xconf *
-menu_expand_xc(xconf *xc)
+menu_expand_xc(xconf *xc, panel *p)
 {
-    xconf *nxc, *cxc, *smenu_xc;
-    GSList *w;
+    xconf *nxc, *cxc, *smenu_xc, *tmp;
+    GSList *w, *ww;
 
     ENTER;
     if (!xc)
@@ -51,26 +67,127 @@ menu_expand_xc(xconf *xc)
             xconf_del(smenu_xc, FALSE);
             continue;
         }
-        /* XXX: write handlers for these types */
-        if (!strcmp(cxc->name, "include"))
+        /* CLIP */
+        if (!strcmp(cxc->name, "include")) {
+            for (ww = cxc->sons; ww; ww = g_slist_next(ww)) {
+                tmp = ww->data;
+                if (!strcmp(tmp->name, "name"))
+                    xconf_append_sons(nxc, menu_expand_include(tmp->value, p));
+            }
             continue;
-        xconf_append(nxc, menu_expand_xc(cxc));
+        }
+        /* /CLIP */
+        xconf_append(nxc, menu_expand_xc(cxc, p));
     }
     return nxc;
 }
 
-#if 0
 /* XXX: should be global service with following API
  * register_command, unregister_command, run_command
  */
 static void
-run_command(GtkWidget *widget, void (*cmd)(void))
+run_callback(GtkWidget *widget, void (*cmd)(void))
 {
     ENTER;
     cmd();
     RET();
 }
-#endif
+
+static gchar **
+get_dynlist(const gchar *cmdline)
+{
+    GError *error = NULL;
+    gchar **lines = NULL, *out = NULL;
+    gint size = 0;
+
+    ENTER;
+    if (cmdline) {
+        if (! g_spawn_command_line_sync(cmdline, &out, NULL, NULL, &error)) {
+            ERR("can't spawn %s\nError is %s\n", (char *)cmdline, error->message);
+            g_error_free(error);
+        }
+    }
+    size = strlen(out);
+    if(size > 0 && out[size - 1] == '\n') {
+        out[size - 1] = 0;
+    }
+    lines = g_strsplit(out, "\n", 0);
+    g_free(out);
+    RET(lines);
+}
+
+static GtkWidget *
+make_dynlist(plugin_instance *p, GtkWidget *menu, gchar *listcmd, gchar *action, 
+						gchar *icon, gchar *image, gchar *name)
+{
+    int i;
+    menu_priv *m = (menu_priv *)p;
+    GtkWidget *mi, *picture = NULL;
+    gchar **dynlist;
+
+    ENTER;
+    dynlist = get_dynlist(listcmd);
+
+    for(i = 0; i < g_strv_length(dynlist); i++) {
+        DBG("new list item: %s", dynlist[i]);
+        // action and name need a '%1$s' and must escape ocher '%'
+        gchar *exec = g_strdup_printf(action, dynlist[i]);
+        gchar *title = (name != NULL) ? g_strdup_printf(name, dynlist[i]) : dynlist[i];
+
+        if(icon != NULL) {
+            picture = fb_image_new(icon, NULL, m->iconsize, m->iconsize);
+        } else if(image != NULL) {
+            picture = fb_image_new(NULL, image, m->iconsize, m->iconsize);
+        }
+        mi = gtk_image_menu_item_new_with_label(title);
+        gtk_image_menu_item_set_image(GTK_IMAGE_MENU_ITEM(mi), picture);
+        g_signal_connect_swapped(G_OBJECT(mi), "activate", (GCallback)run_app, exec);
+        g_object_set_data_full(G_OBJECT(mi), "item-name", title, g_free);
+        gtk_menu_shell_append(GTK_MENU_SHELL(menu), mi);
+        gtk_widget_show_all(mi);
+    }
+    g_strfreev(dynlist);
+    RET(mi);
+}
+
+static GtkWidget *
+menu_create_dynlist(plugin_instance *p, xconf *xc, GtkWidget *menu)
+{
+    GtkWidget *mi;
+    gchar *listcmd, *action, *icon, *image, *name;
+    listcmd = action = icon = image = name = NULL;
+    GSList *w;
+    xconf *nxc;
+    
+    if (!xc)
+        return NULL;
+    for (w = xc->sons; w ; w = g_slist_next(w))
+    {
+        nxc = w->data;
+        if (!strcmp(nxc->name, "listcommand"))
+            listcmd = g_strdup(nxc->value);
+        else if (!strcmp(nxc->name, "action"))
+            action = g_strdup(nxc->value);
+        else if (!strcmp(nxc->name, "icon"))
+            icon = g_strdup(nxc->value);
+        else if (!strcmp(nxc->name, "image"))
+            image = g_strdup(nxc->value);
+        else if (!strcmp(nxc->name, "name"))
+            name = g_strdup(nxc->value);
+	else
+            continue;
+    }    
+    
+    mi = make_dynlist(p, menu, listcmd, action, icon, image, name);
+
+    g_free(listcmd);
+    g_free(action);
+    g_free(icon);
+    g_free(image);
+    g_free(name);
+
+    RET(mi);
+}
 
 static GtkWidget *
 menu_create_separator()
@@ -126,18 +243,15 @@ menu_create_item(xconf *xc, GtkWidget *m
     XCG(xc, "command", &cmd, str);
     if (cmd)
     {
-        /* XXX: implement command API */
-#if 0
         command *tmp;
         
         for (tmp = commands; tmp->name; tmp++)
             if (!g_ascii_strcasecmp(cmd, tmp->name))
             {
                 g_signal_connect(G_OBJECT(mi), "activate",
-                        (GCallback)run_command, tmp->cmd);
+                        (GCallback)run_callback, tmp->cmd);
                 goto done;
             }
-#endif        
     }
    
 done:
@@ -148,7 +262,7 @@ done:
  * If @ret_menu is TRUE, then a menu is returned. Otherwise,
  * button is created, linked to a menu and returned instead. */
 static GtkWidget *
-menu_create_menu(xconf *xc, gboolean ret_menu)
+menu_create_menu(xconf *xc, gboolean ret_menu, plugin_instance *p)
 {
     GtkWidget *mi, *menu;
     GSList *w;
@@ -166,7 +280,9 @@ menu_create_menu(xconf *xc, gboolean ret
         else if (!strcmp(nxc->name, "item"))
             mi = menu_create_item(nxc, NULL);
         else if (!strcmp(nxc->name, "menu"))
-            mi = menu_create_menu(nxc, FALSE);
+            mi = menu_create_menu(nxc, FALSE, p);
+	else if (!strcmp(nxc->name, "dynamiclist"))
+	    mi = menu_create_dynlist(p, nxc, menu);
         else
             continue;
         gtk_menu_shell_append(GTK_MENU_SHELL(menu), mi);
@@ -183,9 +299,9 @@ menu_create(plugin_instance *p)
     ENTER;
     if (m->menu)
         menu_destroy(m);
-    m->xc = menu_expand_xc(p->xc);
+    m->xc = menu_expand_xc(p->xc, p->panel);
     //xconf_prn(stdout, m->xc, 0, TRUE);
-    m->menu = menu_create_menu(m->xc, TRUE);
+    m->menu = menu_create_menu(m->xc, TRUE, p);
     RET();
 }
 
--- ./plugins/dclock/dclock.c.orig	2010-06-03 20:06:35.000000000 +0200
+++ ./plugins/dclock/dclock.c	2010-06-03 20:06:49.000000000 +0200
@@ -8,6 +8,10 @@
 #include <string.h>
 #include <ctype.h>
 
+/* CLIP */
+#include <signal.h>
+#include <sys/wait.h>
+/* /CLIP */
 
 #include "panel.h"
 #include "misc.h"
--- ./panel/panel.c.orig	2010-06-03 20:06:35.000000000 +0200
+++ ./panel/panel.c	2010-06-03 20:52:22.000000000 +0200
@@ -40,6 +40,208 @@ int log_level = LOG_WARN;
 panel *p;
 panel *the_panel;
 
+/**************************** CLIP ***************************/
+
+#include <sys/wait.h>
+void reconfigure(void);
+void restart(void);
+void quit(void);
+void reboot(void);
+void halt(void);
+
+command commands[] = {
+    { "configure", reconfigure },
+    { "restart", restart },
+    { "quit", quit },
+    { "reboot", reboot },
+    { "halt", halt },
+    { NULL, NULL },
+};
+
+static GPid g_quit_pid = 0;
+static GPid g_autostart_pid = 0;
+
+typedef enum {
+    FBQuitQuit = 0,
+    FBQuitReboot = 100,
+    FBQuitHalt = 101,
+} quit_action_t;
+
+static quit_action_t g_quit_action = FBQuitQuit;
+
+static void
+do_exit(int code)
+{
+        signal(SIGCHLD, SIG_DFL);
+        /* Don't kill ourselves */
+        signal(SIGTERM, SIG_IGN);
+        gtk_main_quit();
+        /* Kill all clients */
+        (void)kill(-1, SIGTERM);
+        force_quit = 1;
+	exit(code);
+}
+
+static void
+quit_cld_reaper(GPid pid, gint status, gpointer data)
+{
+    if (!(g_quit_pid && pid == g_quit_pid))
+        return;
+    if (WIFEXITED(status) && !WEXITSTATUS(status)) {
+    	do_exit(g_quit_action);
+    } else {
+        ERR("Quit cancelled\n");
+        g_quit_pid = 0;
+    }
+}
+
+static void
+autostart_cld_reaper(GPid pid, gint status, gpointer data)
+{
+    if (!(g_autostart_pid && pid == g_autostart_pid))
+        return;
+    if (WIFEXITED(status) && !WEXITSTATUS(status)) {
+    	do_exit(FBQuitQuit);
+    } else {
+        ERR("Quit cancelled\n");
+        g_quit_pid = 0;
+    }
+}
+
+#define BEGIN_CHILD_PROTECT() do {\
+	sigemptyset(&set); \
+	sigaddset(&set, SIGCHLD); \
+	sigprocmask(SIG_BLOCK, &set, &oldset); \
+} while (0)
+
+#define END_CHILD_PROTECT() do {\
+	sigemptyset(&set); \
+	sigaddset(&set, SIGCHLD); \
+	sigprocmask(SIG_UNBLOCK, &set, &oldset); \
+} while (0)
+
+static void request_quit(quit_action_t action, 
+                    const char *title, const char *msg)
+{
+    GPid pid;
+    sigset_t set, oldset;
+    GError *err = NULL;
+    gboolean ret;
+
+    char *argv[] = {
+        EPREFIX"/bin/Xdialog",
+        "--title", title, "--yesno",
+        msg,
+        "0", "0", 
+        NULL };
+
+    ENTER;
+    BEGIN_CHILD_PROTECT();
+    if (g_quit_pid)
+        goto out;
+
+    g_quit_action = action;
+    ret = g_spawn_async(NULL, argv, NULL, G_SPAWN_DO_NOT_REAP_CHILD,
+                            NULL, NULL, &pid, &err);
+
+    if (ret == TRUE) {
+        g_quit_pid = pid;
+        (void)g_child_watch_add(pid, quit_cld_reaper, NULL);
+    } else {
+        if (err != NULL)
+            ERR("Spawn error: %s\n", err->message);
+        else
+            ERR("Spawn error, no message\n");
+    }
+out:
+    END_CHILD_PROTECT();
+    RET();
+}
+
+void
+quit(void)
+{
+    ENTER;
+/* CLIP */
+    request_quit(FBQuitQuit, "Déconnexion", "Confirmez-vous la déconnexion ?");
+/* CLIP */
+    RET();
+}
+
+/* CLIP */
+void
+reboot(void)
+{
+    ENTER;
+    request_quit(FBQuitReboot, "Redémarrage", "Confirmez-vous le redémarrage "
+                    "du système ?");
+    RET();
+}
+
+void
+halt(void)
+{
+    ENTER;
+    request_quit(FBQuitHalt, "Arrêt", "Confirmez-vous l'arrêt "
+                    "du système ?");
+    RET();
+}
+
+void
+reconfigure(void)
+{
+    ENTER;
+    ERR("reconfigure not implemented yet\n");
+    RET();
+}
+
+void
+restart(void)
+{
+    ENTER;
+    ERR("restart not implemented yet\n");
+    RET();
+}
+
+static void do_autostart(char *action)
+{
+    GPid pid;
+    sigset_t set, oldset;
+    GError *err = NULL;
+    gboolean ret;
+
+    char *argv[] = {
+        action,
+        NULL };
+
+    ENTER;
+    BEGIN_CHILD_PROTECT();
+    if (g_autostart_pid)
+        goto out;
+
+    ret = g_spawn_async(NULL, argv, NULL, G_SPAWN_DO_NOT_REAP_CHILD,
+                            NULL, NULL, &pid, &err);
+
+    if (ret == TRUE) {
+        g_autostart_pid = pid;
+        (void)g_child_watch_add(pid, autostart_cld_reaper, NULL);
+    } else {
+        if (err != NULL)
+            ERR("Spawn error: %s\n", err->message);
+        else
+            ERR("Spawn error, no message\n");
+	END_CHILD_PROTECT();
+	do_exit(1);
+    }
+out:
+    END_CHILD_PROTECT();
+    RET();
+}
+
+
+/**************************** CLIP ***************************/
+
+
 void
 panel_set_wm_strut(panel *p)
 {
@@ -178,7 +380,12 @@ static gint
 panel_destroy_event(GtkWidget * widget, GdkEvent * event, gpointer data)
 {
     ENTER;
+    /* CLIP */
+    signal(SIGCHLD, SIG_DFL);
     gtk_main_quit();
+    /* Kill all clients */
+    (void)kill(-1, SIGTERM);
+    /* CLIP */    
     force_quit = 1;
     RET(FALSE);
 }
@@ -510,6 +717,77 @@ panel_start_gui(panel *p)
     RET();
 }
 
+/* CLIP */
+
+static void
+expand_plugin(gpointer data, gpointer udata)
+{
+	plugin_instance *this = data;
+	gboolean expand, fill;
+	guint padding;
+	GtkPackType pack_type;
+
+	gtk_box_query_child_packing(GTK_BOX(this->panel->box), this->pwid, 
+							&expand, &fill, &padding, &pack_type);
+	
+	gtk_box_set_child_packing(GTK_BOX(this->panel->box), this->pwid,
+							this->expand, fill, padding, pack_type);
+}
+
+
+static void
+unexpand_plugin(gpointer data, gpointer udata)
+{
+	plugin_instance *this = data;
+	gboolean expand, fill;
+	guint padding;
+	GtkPackType pack_type;
+
+	gtk_box_query_child_packing(GTK_BOX(this->panel->box), this->pwid, 
+							&expand, &fill, &padding, &pack_type);
+	
+	gtk_box_set_child_packing(GTK_BOX(this->panel->box), this->pwid,
+							FALSE, fill, padding, pack_type);
+}
+
+void
+panel_maximize(panel *p)
+{
+    p->widthtype = WIDTH_PERCENT;
+    p->width = 100;
+
+    DBG("panel_maximize\n");
+	p->unexpand = FALSE;
+    g_list_foreach(p->plugins, expand_plugin, NULL);
+    calculate_position(p);
+    gdk_window_move_resize(p->topgwin->window, p->ax, p->ay, p->aw, p->ah);
+    if (p->setstrut)
+        panel_set_wm_strut(p);
+}
+
+void
+panel_minimize(panel *p, int width)
+{
+    p->widthtype = WIDTH_PIXEL;
+    p->width = width;
+
+    DBG("panel_minimize %d\n", width);
+	p->unexpand = TRUE;
+    g_list_foreach(p->plugins, unexpand_plugin, NULL);
+	/* TODO
+    if (p->autohide)
+        panel_enter(NULL, NULL, p);
+	*/
+
+    calculate_position(p);
+    gdk_window_move_resize(p->topgwin->window, p->ax, p->ay, p->aw, p->ah);
+    if (p->setstrut)
+        panel_set_wm_strut(p);
+}
+/* /CLIP */
+
+
+
 static int
 panel_parse_global(xconf *xc)
 {
@@ -680,6 +958,9 @@ usage()
     printf(" --log <number> -- set log level 0-5. 0 - none 5 - chatty\n");
     printf(" --configure -- launch configuration utility\n");
     printf(" --profile name -- use specified profile\n");
+    /* CLIP */
+    printf(" --options <opt1> <opt2> ... -- add specified options (must come last)\n");
+    /* /CLIP */
     printf("\n");
     printf(" -h  -- same as --help\n");
     printf(" -p  -- same as --profile\n");
@@ -705,7 +986,11 @@ sig_usr1(int signum)
 {
     if (signum != SIGUSR1)
         return;
+/* CLIP */
     gtk_main_quit();
+    /* Kill all clients */
+    (void)kill(-1, SIGTERM);
+/* CLIP */
 }
 
 static void
@@ -719,7 +1004,7 @@ sig_usr2(int signum)
 
 
 static void
-do_argv(int argc, char *argv[])
+do_argv(int argc, char *argv[], char ***options, int *optlen)
 {
     int i;
     
@@ -750,6 +1035,20 @@ do_argv(int argc, char *argv[])
             } else {
                 profile = g_strdup(argv[i]);
             }
+        /* CLIP */
+        } else if (!strcmp(argv[i], "--options")) {
+            if (i < argc - 1) {
+                i++;
+                *options = argv + i;
+                *optlen = argc -i;
+                break;
+            }
+        } else if (!strcmp(argv[i], "--autostart")) {
+            if (i < argc - 1) {
+                i++;
+                do_autostart(argv[i]);
+            }
+        /* /CLIP */
         } else {
             printf("fbpanel: unknown option - %s\n", argv[i]);
             usage();
@@ -772,13 +1071,17 @@ gchar *panel_get_profile_file()
 static void
 ensure_profile()
 {
+#if 0
     gchar *cmd;
+#endif
 
     if (g_file_test(profile_file,
             G_FILE_TEST_EXISTS | G_FILE_TEST_IS_REGULAR))
     {
         return;
     }
+	/* CLIP */
+#if 0
     cmd = g_strdup_printf("%s %s", LIBEXECDIR "/fbpanel/make_profile",
         profile);
     g_spawn_command_line_sync(cmd, NULL, NULL, NULL, NULL);
@@ -788,6 +1091,7 @@ ensure_profile()
     {
         return;
     }
+#endif
     ERR("Can't open profile %s - %s\n", profile, profile_file);
     exit(1);
 }
@@ -795,23 +1099,39 @@ ensure_profile()
 int
 main(int argc, char *argv[])
 {
+    char **options = NULL;
+    int optlen = 0;
+#ifdef NLS
+    setlocale(LC_ALL, "");
+    bindtextdomain("fbpanel", PREFIX "/share/locale");
+    bind_textdomain_codeset("fbpanel", "UTF-8");
+    textdomain("fbpanel");
+#else
     setlocale(LC_CTYPE, "");
+#endif
     gtk_set_locale();
     gtk_init(&argc, &argv);
     XSetLocaleModifiers("");
     XSetErrorHandler((XErrorHandler) handle_error);
     fb_init();
-    do_argv(argc, argv);
-    profile_file = g_build_filename(g_get_user_config_dir(),
+    do_argv(argc, argv, &options, &optlen);
+	/* CLIP */
+    profile_file = g_build_filename(DATADIR,
         "fbpanel", profile, NULL);
     ensure_profile();
+	/* /CLIP */
     gtk_icon_theme_append_search_path(gtk_icon_theme_get_default(), IMGPREFIX);
     signal(SIGUSR1, sig_usr1);
     signal(SIGUSR2, sig_usr2);
 
     do {
         the_panel = p = g_new0(panel, 1);
-        p->xc = xconf_new_from_file(profile_file, profile);
+        /* CLIP */
+        memset(p, 0, sizeof(panel));
+        p->options = options;
+        p->optlen = optlen;
+        /* /CLIP */
+        p->xc = xconf_new_from_file(profile_file, profile, p);
         if (!p->xc)
             exit(1);
 
@@ -829,3 +1149,19 @@ main(int argc, char *argv[])
     exit(0);
 }
 
+/* CLIP */
+inline int 
+has_option(const char *cond, const panel *p)
+{
+    int i;
+    for (i = 0 ; i < p->optlen; i++) {
+        if (!g_ascii_strcasecmp(cond, p->options[i]))
+            return 1;
+    }
+    return 0;
+}
+
+
+/* /CLIP */
+
+
--- ./panel/plugin.c.orig	2010-06-03 20:06:35.000000000 +0200
+++ ./panel/plugin.c	2010-06-03 20:06:49.000000000 +0200
@@ -74,7 +74,7 @@ class_put(char *name)
     
     s = g_strdup_printf(LIBDIR "/fbpanel/%s.so", name);
     DBG("loading module %s\n", s);
-    m = g_module_open(s, G_MODULE_BIND_LAZY);                
+    m = g_module_open(s, 0);                
     g_free(s);
     if (m) {
         /* Close it twise to undo initial open in class_get */
@@ -100,7 +100,7 @@ class_get(char *name)
     }
     s = g_strdup_printf(LIBDIR "/fbpanel/%s.so", name);
     DBG("loading module %s\n", s);
-    m = g_module_open(s, G_MODULE_BIND_LAZY);                
+    m = g_module_open(s, 0);                
     g_free(s);
     if (m) {
         if (class_ht && (tmp = g_hash_table_lookup(class_ht, name))) {
@@ -159,8 +159,14 @@ plugin_start(plugin_instance *this)
     if (!this->class->invisible) {
         this->pwid = gtk_bgbox_new();
         gtk_widget_set_name(this->pwid, this->class->type);
-        gtk_box_pack_start(GTK_BOX(this->panel->box), this->pwid, this->expand,
-                TRUE, this->padding);
+        /* CLIP */
+        if (this->panel->unexpand) 
+            gtk_box_pack_start(GTK_BOX(this->panel->box), this->pwid, FALSE, TRUE,
+                  this->padding);
+        else
+            gtk_box_pack_start(GTK_BOX(this->panel->box), this->pwid, this->expand, TRUE,
+                  this->padding);
+        /* /CLIP */
         DBG("%s expand %d\n", this->class->type, this->expand);
         gtk_container_set_border_width(GTK_CONTAINER(this->pwid), this->border);
         DBG("here this->panel->transparent = %d\n", this->panel->transparent);
--- ./panel/Makefile.in.orig	2010-06-03 20:06:35.000000000 +0200
+++ ./panel/Makefile.in	2010-06-03 20:06:49.000000000 +0200
@@ -7,12 +7,42 @@ SRCS += xconf.c gconf.c gconf_panel.c gc
 BINTARGET = fbpanel
 LDFLAGS += $(GMODULE_LIBS)
 
+LANGS := fr_FR
+
+ifeq (enabled, $(NLS))
+MO := ${foreach lang, ${LANGS}, ${lang}.mo}
+endif
+
 ifeq (enabled,$(STATIC_BUILD))
 OBJS += $(wildcard $(TOPDIR)/plugins/*/*.o)
 endif
 
-install:
+ifeq (enabled, $(NLS))
+install_mo: $(MO)
+	list='$(LANGS)'; for lang in $$list; do \
+		install -D $$lang.mo $(DESTDIR)$(PREFIX)/share/locale/$$lang/LC_MESSAGES/fbpanel.mo; \
+	done
+
+uninstall_mo:
+	list='$(LANGS)'; for lang in $$list; do \
+		$(RM) $(DESTDIR)$(PREFIX)/share/locale/$$lang/LC_MESSAGES/fbpanel.mo; \
+	done
+else
+install_mo:
+	echo "No NLS support"
+uninstall_mo:
+	echo "No NLS support"
+endif
+
+install: install_mo 
 	$(install) 755 $(BINDIR) 755 $(BINTARGET)
 
 
 include %%topdir%%/rules.mk
+
+all: $(BINTARGET) $(MO)
+
+%.mo:%.po
+	$(call summary,MSGFMT  ,$@)
+	$(Q)msgfmt -o $@ $<
+
--- ./panel/xconf.c.orig	2010-06-03 20:06:35.000000000 +0200
+++ ./panel/xconf.c	2010-06-03 20:06:49.000000000 +0200
@@ -10,7 +10,9 @@
 #include "dbg.h"
 
 
-enum { LINE_NONE, LINE_BLOCK_START, LINE_BLOCK_END, LINE_VAR };
+/* CLIP */
+enum { LINE_NONE, LINE_BLOCK_START, LINE_BLOCK_END, LINE_VAR, LINE_IF, LINE_IFNOT, LINE_ENDIF };
+/* /CLIP */
 
 #define LINE_LENGTH 256
 typedef struct {
@@ -259,6 +261,33 @@ read_line(FILE *fp, line *s)
         if (s->str[0] == '#' || s->str[0] == 0) {
             continue;
         }
+
+        /* CLIP */
+        if (!strncasecmp("if", s->str, 2)) { 
+            s->t[0] = s->str;
+            for (tmp = s->str; isalnum(*tmp); tmp++);
+            for (tmp2 = tmp; isspace(*tmp2); tmp2++);
+            *tmp = 0;
+            s->t[1] = tmp2;
+            if (!g_ascii_strcasecmp("ifnot", s->t[0])) { 
+                s->type = LINE_IFNOT;
+                DBG( ">> IFNOT %s\n", s->t[1]);
+            } else {
+                s->type = LINE_IF;
+                DBG( ">> IF %s\n", s->t[1]);
+            }
+            break;
+        }
+
+        if (!strncasecmp("endif", s->str, 5)) {
+            s->t[0] = s->str;
+            s->type = LINE_ENDIF;
+
+            DBG( ">> ENDIF\n");
+            break;
+        }
+        /* /CLIP */
+
         DBG( ">> %s\n", s->str);
         if (!g_ascii_strcasecmp(s->str, "}")) {
             s->type = LINE_BLOCK_END;
@@ -287,17 +316,33 @@ read_line(FILE *fp, line *s)
 
 
 static xconf *
-read_block(FILE *fp, gchar *name)
+read_block(FILE *fp, gchar *name, panel *p)
 {
     line s;
     xconf *x, *xs;
+    /* CLIP */
+    int ignore = 0, ifdepth = 0, skip = 0;
+    /* /CLIP */
 
     x = xconf_new(name, NULL);
+    /* CLIP */
     while (read_line(fp, &s) != LINE_NONE)
     {
+	if (p)
+		skip = handle_options(&s, p, &ifdepth, &ignore);
+        if (skip < 0)
+	{
+	    printf("syntax error\n");
+	    exit(1);
+	}
+        if (skip)
+            continue;
+        if (ignore)
+            continue;
+        /* /CLIP */
         if (s.type == LINE_BLOCK_START)
         {
-            xs = read_block(fp, s.t[0]);
+            xs = read_block(fp, s.t[0], p);
             xconf_append(x, xs);
         }
         else if (s.type == LINE_BLOCK_END)
@@ -309,20 +354,21 @@ read_block(FILE *fp, gchar *name)
         }
         else
         {
-            printf("syntax error\n");
+            printf("syntax error: %s %s\n", s.t[0], s.t[1]);
             exit(1);
         }
     }
     return x;
 }
 
-xconf *xconf_new_from_file(gchar *fname, gchar *name)
+xconf *xconf_new_from_file(gchar *fname, gchar *name, void *_p)
 {
+    panel *p = _p;
     FILE *fp = fopen(fname, "r");
     xconf *ret = NULL;
     if (fp)
     {
-        ret = read_block(fp, name);
+        ret = read_block(fp, name, p);
         fclose(fp);
     }
     //xconf_prn(stdout, ret, 0, FALSE);
@@ -385,3 +431,37 @@ xconf_cmp(xconf *a, xconf *b)
     }
     return (as != bs);
 }
+
+/* CLIP */
+
+int
+handle_options(const void *_s, const panel *p, int *ifdepth, int *ignore)
+{
+    const line *s = _s;
+
+    switch (s->type) {
+        case LINE_IF:
+            *ifdepth += 1;
+            if (!*ignore && !has_option(s->t[1], p))
+                *ignore = *ifdepth;
+            return 1;
+        case LINE_IFNOT:
+            *ifdepth += 1;
+            if (!*ignore && has_option(s->t[1], p))
+                *ignore = *ifdepth;
+            return 1;
+        case LINE_ENDIF:
+            if (!*ifdepth) {
+                ERR("menu: endif without if\n");
+                return -1;
+            }
+            if (*ignore == *ifdepth)
+                *ignore = 0;
+            *ifdepth -= 1;
+            return 1;
+        default:
+            return 0;
+    }
+}
+
+/* /CLIP */
--- ./panel/panel.h.orig	2010-06-03 20:06:35.000000000 +0200
+++ ./panel/panel.h	2010-06-03 20:06:49.000000000 +0200
@@ -8,6 +8,11 @@
 
 #include "config.h"
 
+#ifdef NLS
+#include <libintl.h>
+#include <locale.h>
+#endif
+
 #include "bg.h"
 #include "ev.h"
 #include "xconf.h"
@@ -80,6 +85,12 @@ typedef struct _panel
     gboolean (*ah_state)(struct _panel *);
 
     xconf *xc;
+
+    /* CLIP */
+    char **options;
+    int optlen;
+    gboolean unexpand;
+    /* /CLIP */
 } panel;
 
 
@@ -178,6 +189,13 @@ extern int verbose;
 extern gint force_quit;
 extern FbEv *fbev;
 
+/* CLIP */
+extern int has_option(const char *cond, const panel *p);
+extern int handle_options(const void *s, const panel *p, int *ifdepth, int *ignore);
+extern void panel_maximize(panel *p);
+extern void panel_minimize(panel *p, int width);
+/* /CLIP */
+
 #define FBPANEL_WIN(win)  gdk_window_lookup(win)
 void panel_set_wm_strut(panel *p);
 
--- ./panel/xconf.h.orig	2010-06-03 20:06:35.000000000 +0200
+++ ./panel/xconf.h	2010-06-03 20:06:49.000000000 +0200
@@ -30,7 +30,7 @@ void xconf_prn(FILE *fp, xconf *x, int n
 xconf *xconf_find(xconf *x, gchar *name, int no);
 xconf *xconf_dup(xconf *xc);
 gboolean xconf_cmp(xconf *a, xconf *b);
-xconf *xconf_new_from_file(gchar *fname, gchar *name);
+xconf *xconf_new_from_file(gchar *fname, gchar *name, void *panel);
 void xconf_save_to_file(gchar *fname, xconf *xc);
 void xconf_save_to_profile(xconf *xc);
 
--- ./configure.orig	2010-06-03 20:06:35.000000000 +0200
+++ ./configure	2010-06-03 20:06:49.000000000 +0200
@@ -338,6 +338,7 @@ add_var localstatedir "modifiable single
 add_var topdir "project's top directory" '`pwd`'
 add_var version "version" '`< version`'
 add_feature debug "debug build" disabled
+add_feature nls "national language support" disabled
 
 #########################
 ## User settings here  ##
--- ./rules.mk.orig	2010-06-03 20:06:35.000000000 +0200
+++ ./rules.mk	2010-06-03 20:06:49.000000000 +0200
@@ -49,6 +49,10 @@ ifeq ($(T),plugins)
     CFLAGSX += -DPLUGIN
 endif
 
+#ifeq (enabled,$(NLS))
+#    CFLAGS += -DNLS
+#endif
+
 override CFLAGS  += $(CFLAGSX)
 override LDFLAGS += $(LDFLAGSX)
 
